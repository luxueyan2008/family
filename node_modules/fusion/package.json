{
  "name": "fusion",
  "description": "Merge Files into Javascript Namespace",
  "version": "0.1.0",
  "keywords": [
    "jst",
    "templates",
    "namespace",
    "merge",
    "fusion"
  ],
  "homepage": "https://github.com/brunch/fusion",
  "author": {
    "name": "Nik Graf @nikgraf"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/brunch/fusion/raw/master/LICENSE"
    }
  ],
  "engines": [
    "node"
  ],
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/fusion",
  "bin": {
    "fusion": "./bin/fusion"
  },
  "dependencies": {
    "watch": "0.3.0",
    "yaml": "0.1.1",
    "underscore": "1.1.4"
  },
  "devDependencies": {
    "coffee-script": ">= 1.0.1",
    "vows": "0.5.6"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/brunch/fusion.git"
  },
  "bugs": {
    "url": "http://github.com/brunch/fusion/issues"
  },
  "readme": "# Fusion\n\nFusion is a simple tool to merge multiple JavaScript templates (mustache, handlebars, jquery-tmpl, â€¦) into one namespaced template object. It also allows you to define your own precompiling functions.\n\n## What is fusion good for?\n\nYou might have noticed that using script tags to manage your JavaScript templates can become quite a mess if you have a bunch of them. It's a good idea to split them into several files. Fusion helps you bring them back together in one neatly organized namespace.\n\nFor example if you have a directory structure like\n\n    templates/home.html\n    templates/notes/overview.html\n    templates/notes/detail.html\n\nfusion would compile it to\n\n    (function(){\n      window.templates = {};\n      window.templates.home = '<content of home.html>';\n      window.templates.notes = {};\n      window.templates.notes.overview = '<content of overview.html>';\n      window.templates.notes.detail = '<content of detail.html>';\n    }).call(this);\n\n***camel case*** Fusion generates camel case namespaces. So if you have\n\n    templates/task_list/new_comment.html\n\nit will generate\n\n    templates.taskList.newComment.html\n\n## Installation\n\n    npm install fusion\n\n## How to use\n\n### Command-line\n\nYou can run the script to compile templates via\n\n    fusion [options] [<directory>]\n\nOptional use `--watch` to watch changes in the given directory.\nYou don't need to set a directory. You can leave it out and use\nthe one from settings or even fusion's default which is 'templates'.\n\nBasically you are able to change these settings:\n\nset output path of templates\n\n    --output [FILE]\n\nset export namespace\n\n    --namespace [VALUE]\n\nset extension of template files which should be merged\n\n    --templateExtension [VALUE]\n\nset path of settings file\n\n    --config [FILE]\n\nset path of the hook file\n\n    --hook [FILE]\n\n#### Example\n\n    fusion --watch --config fusion_settings.yaml\n\n### Settings file\n\nAll options except `--watch` and `--config` can be set in the settings file.\nUnless `--config` is defined the script will search for \"settings.yaml\"\nin the current directory.\n\nPossible settings are\n\n* namespace\n* templateExtension\n* input\n* output\n* hook\n\n### Hooks file\n\nThe hooks file provides a way to overwrite all public methods of fusion.\nProbably the most common case will be to overwrite the compileTemplate method.\n\n#### Example\n\nFor example to use eco's precompiling for our templates we can create a file\nfusion_hooks.js which contains something like this\n\n    var eco = require('eco');\n    var fusion = require('fusion');\n    exports.createTemplateObject = function(content, source, directoryPrefix) {\n      return eco.compile(content, { identifier: fusion.templateNamespace(source, directoryPrefix)});\n    };\n\nThats all you need to add proper precompiling to your templates.\n\nHint: Eco 1.0.2 yet doesn't provide options for compile, please use a master checkout\n\n### Default Settings\n\n* settings file: \"settings.yaml\"\n* namespace: \"window\"\n* template extension: \"html\"\n* input directory: \"templates\"\n* output file: \"templates.js\"\n* hook file: \"fusion_hooks.js\"\n\n### require('fusion');\n\nFor more flexability you can require fusion and run it by your own without the command-line interface.\n\n    var fusion = require('fusion');\n    var settings;\n    settings = fusion.loadSettingsFromFile('settings.yaml');\n    settings = fusion.loadDefaultSettings(settings);\n    settings.watch = true;\n    fusion.run(settings);\n\n### Demo\n\nYou can see it running by switching to demo folder and run it with watch option.\nYou can change anything in the templates, refresh the index.html and see the new content.\n\n    cd demo/simple\n    ./../../bin/fusion --watch\n\n## Development\n\n### Contributing\n\nFeel free to make a pull request or contact me on Twitter @nikgraf.\n\nTo compile src files to lib use\n\n    cake watch\n\n### Tests\n\n    cake test\n\n## Thanks\n\nIt was inspired by [Jammit](http://documentcloud.github.com/jammit/)'s templating functionality. Since Jammit doesn't offer file watching via command-line, it's a bit hard to use for development if you are not on a RubyOnRails stack.\n\nSpecial Thanks to the [CoffeeScript](http://jashkenas.github.com/coffee-script/) Team. We were able to re-use some parts like the optparser.\n\n## TODO\n\n* add cake to rerender all the the demos\n* watch somehow does not work with Textmate - any pointers?\n* output file - mkdirs or warn if directory doesn't exist\n* replace optparser (mabey nomnom?)\n* add github page\n* improve regex in createTemplateObject to work with dotfiles and add option to ignoreDotFiles - tmp and swp files can cause troubles\n",
  "_id": "fusion@0.1.0",
  "dist": {
    "shasum": "5cd21a15e96074c36425d26c197bad92e6b40872"
  },
  "_from": "fusion"
}
